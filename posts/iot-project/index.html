<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Iot Project with ESP 32" /><meta property="og:locale" content="en" /><meta name="description" content="Thinking (brainstorming)" /><meta property="og:description" content="Thinking (brainstorming)" /><link rel="canonical" href="https://gitjmc.github.io/posts/iot-project/" /><meta property="og:url" content="https://gitjmc.github.io/posts/iot-project/" /><meta property="og:site_name" content="JMC-memo" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-03-03T06:35:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Iot Project with ESP 32" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-11-26T18:28:37-05:00","datePublished":"2025-03-03T06:35:00-05:00","description":"Thinking (brainstorming)","headline":"Iot Project with ESP 32","mainEntityOfPage":{"@type":"WebPage","@id":"https://gitjmc.github.io/posts/iot-project/"},"url":"https://gitjmc.github.io/posts/iot-project/"}</script><title>Iot Project with ESP 32 | JMC-memo</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="JMC-memo"><meta name="application-name" content="JMC-memo"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://gitjmc.github.io/assets/img/favicons/avatar.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">JMC-memo</a></div><div class="site-subtitle font-italic">À la demande de sisi</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/gitjmc" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Iot Project with ESP 32</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Iot Project with ESP 32</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/username">Jerbi Mohamed Chamseddine</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1741001700" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2025-03-03 </em> </span> <span> Updated <em class="timeago" data-ts="1764199717" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2025-11-26 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8648 words"> <em>48 min</em> read</span></div></div></div><div class="post-content"><h1 id="thinking-brainstorming">Thinking (brainstorming)</h1><p>Alright, let’s break this down. I’m building an IoT project with ESP controllers (DevKit and CAM) using C code. The data will be stored in InfluxDB, and I want to use Telegraf for data collection and Grafana for visualization. Everything should run in Docker Compose with Docker secrets for secure credential management.</p><p>First, I need to set up the ESP controllers. Since I prefer C code, I’ll use the ESP-IDF framework for programming the ESP32 chips. For the DevKit, I might want to collect sensor data like temperature or humidity. For the CAM, I could capture images or video streams. I’ll need to write C code to interface with the sensors or camera and send the data to a server.</p><p>Now, for the server side, I’ll use Docker Compose to manage the containers. The stack will include:</p><p>InfluxDB: A time-series database to store the IoT data. Telegraf: An agent to collect data from various sources and send it to InfluxDB. Grafana: A visualization tool to create dashboards for the IoT data. Additionally, I might need an MQTT broker like Mosquitto to handle communication between the ESP devices and the server.</p><p>Let me think about how to structure this.</p><p>ESP Controllers:</p><p>For the DevKit, I’ll write C code to read sensor data and publish it to an MQTT topic. For the CAM, I’ll write C code to capture images or video and send them to the server, possibly using HTTP or MQTT. Server Side:</p><p>Mosquitto: An MQTT broker to receive data from the ESP devices. Telegraf: Configured to subscribe to MQTT topics and collect data, then send it to InfluxDB. InfluxDB: Stores the time-series data. Grafana: Connects to InfluxDB to visualize the data. Now, about Docker Compose and Docker secrets.</p><p>I need to ensure that sensitive information like database credentials or API tokens are handled securely. Docker secrets are a good way to manage this.</p><p>Here’s a rough plan:</p><p>Create Docker secrets for sensitive information, such as InfluxDB credentials or MQTT passwords. Configure the services in Docker Compose to use these secrets. For example, InfluxDB can be configured with environment variables from secrets, and Telegraf can read its configuration from a file that uses secrets.</p><p>Wait, actually, Telegraf has support for Docker secrets directly since version 1.27, as mentioned in one of the web results. That could be useful.</p><p>Let me outline the steps more clearly.</p><p>Step 1: Set up the ESP controllers</p><p>Write C code for the DevKit to read sensor data and publish to MQTT. Write C code for the CAM to capture images and send them, perhaps to a specific endpoint or MQTT topic. I need to decide on the data format. For time-series data, InfluxDB expects data in a specific format, so I should ensure that the data sent from the ESP devices can be easily parsed by Telegraf.</p><p>Step 2: Set up the Docker environment</p><p>I’ll need a docker-compose.yml file that defines the services:</p><p>Mosquitto InfluxDB Telegraf Grafana Additionally, I’ll define secrets for credentials.</p><p>For example:</p><p>yaml</p><p>Collapse</p><p>Wrap</p><p>Copy version: ‘3.7’</p><p>secrets: influxdb_username: file: ./secrets/influxdb_username.txt influxdb_password: file: ./secrets/influxdb_password.txt mqtt_password: file: ./secrets/mqtt_password.txt</p><p>services: mosquitto: image: eclipse-mosquitto ports: - “1883:1883” volumes: - ./mosquitto/config:/mosquitto/config secrets: - mqtt_password</p><p>influxdb: image: influxdb:2.7.1 ports: - “8086:8086” environment: DOCKER_INFLUXDB_INIT_MODE: setup DOCKER_INFLUXDB_INIT_USERNAME_FILE: /run/secrets/influxdb_username DOCKER_INFLUXDB_INIT_PASSWORD_FILE: /run/secrets/influxdb_password DOCKER_INFLUXDB_INIT_ORG: myorg DOCKER_INFLUXDB_INIT_BUCKET: mybucket secrets: - influxdb_username - influxdb_password volumes: - influxdb_data:/var/lib/influxdb2</p><p>telegraf: image: telegraf:1.28 volumes: - ./telegraf/telegraf.conf:/etc/telegraf/telegraf.conf:ro depends_on: - influxdb - mosquitto secrets: - mqtt_password</p><p>grafana: image: grafana/grafana:9.5.12 ports: - “3000:3000” volumes: - grafana_data:/var/lib/grafana depends_on: - influxdb</p><p>volumes: influxdb_data: grafana_data: Wait, I need to adjust this. For InfluxDB 2.x, the setup is a bit different. It uses tokens for authentication, not username and password directly. But for simplicity, maybe I can use InfluxDB 1.8, which supports username and password.</p><p>Alternatively, I can stick with InfluxDB 2.x and manage tokens properly.</p><p>Actually, in the web results, there are examples using InfluxDB 2.x with Docker secrets for the admin token.</p><p>Let me check that.</p><p>In one of the results, it shows how to use Docker secrets for InfluxDB 2.x:</p><p>yaml</p><p>Collapse</p><p>Wrap</p><p>Copy services: influxdb2: image: influxdb:2 ports: - 8086:8086 environment: DOCKER_INFLUXDB_INIT_MODE: setup DOCKER_INFLUXDB_INIT_USERNAME_FILE: /run/secrets/influxdb2-admin-username DOCKER_INFLUXDB_INIT_PASSWORD_FILE: /run/secrets/influxdb2-admin-password DOCKER_INFLUXDB_INIT_ADMIN_TOKEN_FILE: /run/secrets/influxdb2-admin-token DOCKER_INFLUXDB_INIT_ORG: docs DOCKER_INFLUXDB_INIT_BUCKET: home secrets: - influxdb2-admin-username - influxdb2-admin-password - influxdb2-admin-token So, I can use this approach.</p><p>For Telegraf, I need to configure it to connect to MQTT and InfluxDB.</p><p>I can create a telegraf.conf file that uses the Docker secrets.</p><p>Wait, with Telegraf 1.27 and later, there’s support for secret stores, including Docker secrets.</p><p>So, in the telegraf.conf, I can define secrets like this:</p><p>toml</p><p>Collapse</p><p>Wrap</p><p>Copy [[inputs.mqtt_consumer]] servers = [“tcp://mosquitto:1883”] topics = [“sensors/#”] username = “[[DOCKER-SECRET:mqtt_username]]” password = “[[DOCKER-SECRET:mqtt_password]]”</p><p>[[outputs.influxdb_v2]] urls = [“http://influxdb:8086”] token = “[[DOCKER-SECRET:influxdb_token]]” organization = “myorg” bucket = “mybucket” Then, in the Docker Compose file, I can define the secrets and make them available to Telegraf.</p><p>Wait, actually, for Telegraf to use Docker secrets, I need to configure the secret store.</p><p>According to the documentation, I can add a secret store configuration in telegraf.conf:</p><p>toml</p><p>Collapse</p><p>Wrap</p><p>Copy [[secretstores.docker]] id = “docker_secrets” container_id = “telegraf” Then, I can reference the secrets like:</p><p>toml</p><p>Collapse</p><p>Wrap</p><p>Copy [[inputs.mqtt_consumer]] servers = [“tcp://mosquitto:1883”] topics = [“sensors/#”] username = “[[SECRET:docker_secrets:mqtt_username]]” password = “[[SECRET:docker_secrets:mqtt_password]]”</p><p>[[outputs.influxdb_v2]] urls = [“http://influxdb:8086”] token = “[[SECRET:docker_secrets:influxdb_token]]” organization = “myorg” bucket = “mybucket” And in the Docker Compose file, I need to mount the secrets into the Telegraf container.</p><p>Wait, actually, with Docker Compose, when I define secrets in the service, they are mounted as files in /run/secrets/.</p><p>But for Telegraf’s Docker secret store, it expects to read from the Docker daemon’s secret store.</p><p>Wait, I think I need to clarify this.</p><p>Upon checking the Telegraf documentation, the Docker secret store plugin reads secrets from the Docker daemon’s secret store, which in Docker Compose is managed through the secrets section.</p><p>So, if I define secrets in Docker Compose, and reference them in the Telegraf service, Telegraf can access them using the Docker secret store plugin.</p><p>For example:</p><p>In docker-compose.yml:</p><p>yaml</p><p>Collapse</p><p>Wrap</p><p>Copy services: telegraf: image: telegraf:1.28 volumes: - ./telegraf/telegraf.conf:/etc/telegraf/telegraf.conf:ro secrets: - mqtt_username - mqtt_password - influxdb_token Then, in telegraf.conf:</p><p>toml</p><p>Collapse</p><p>Wrap</p><p>Copy [[secretstores.docker]] id = “docker_secrets”</p><p>[[inputs.mqtt_consumer]] servers = [“tcp://mosquitto:1883”] topics = [“sensors/#”] username = “[[SECRET:docker_secrets:mqtt_username]]” password = “[[SECRET:docker_secrets:mqtt_password]]”</p><p>[[outputs.influxdb_v2]] urls = [“http://influxdb:8086”] token = “[[SECRET:docker_secrets:influxdb_token]]” organization = “myorg” bucket = “mybucket” Wait, actually, the secret store id might need to be specified correctly.</p><p>Let me confirm the syntax.</p><p>Upon checking the Telegraf documentation, the Docker secret store uses the container’s secrets mounted at /run/secrets/.</p><p>So, in the telegraf.conf, I can define:</p><p>toml</p><p>Collapse</p><p>Wrap</p><p>Copy [[secretstores.docker]] id = “docker” path = “/run/secrets” Then, reference the secrets like:</p><p>toml</p><p>Collapse</p><p>Wrap</p><p>Copy [[inputs.mqtt_consumer]] servers = [“tcp://mosquitto:1883”] topics = [“sensors/#”] username = “[[SECRET:docker:mqtt_username]]” password = “[[SECRET:docker:mqtt_password]]”</p><p>[[outputs.influxdb_v2]] urls = [“http://influxdb:8086”] token = “[[SECRET:docker:influxdb_token]]” organization = “myorg” bucket = “mybucket” Yes, that should work.</p><p>So, in summary, for the server side:</p><p>Use Docker Compose to define services: Mosquitto, InfluxDB, Telegraf, Grafana. Define secrets for sensitive credentials. Configure InfluxDB with initial setup using environment variables and secrets. Configure Telegraf to use the Docker secret store to access credentials for MQTT and InfluxDB. Configure Grafana to connect to InfluxDB. For Grafana, I might also need to provision data sources and dashboards, but that can be done later.</p><p>Now, about the ESP controllers.</p><p>I need to write C code for the ESP32 to connect to WiFi, connect to the MQTT broker, and publish data.</p><p>For the DevKit, let’s say I have a temperature sensor. I’ll read the temperature and publish it to an MQTT topic, say “sensors/temperature”.</p><p>For the CAM, perhaps I’ll capture an image periodically and send it to the server. But sending images over MQTT might not be efficient. Alternatively, I could use HTTP to upload the image to a web server, but since I’m using Docker Compose, I might need to add another service for handling image uploads.</p><p>Wait, perhaps I can use Node-RED or something similar to handle incoming data, including images.</p><p>But to keep it simple, maybe for the CAM, I’ll just send some metadata or a small thumbnail via MQTT, and handle full images separately if needed.</p><p>Alternatively, I can use FTP or another protocol, but that might complicate things.</p><p>For now, let’s assume that for the CAM, I’ll send some numerical data, like the number of detected objects or something, via MQTT.</p><p>So, both ESP devices will publish data to MQTT topics.</p><p>Then, Telegraf will subscribe to those topics and forward the data to InfluxDB.</p><p>In Telegraf, I need to configure the MQTT input plugin and the InfluxDB output plugin.</p><p>Also, I need to parse the MQTT messages into InfluxDB line protocol format.</p><p>Assuming the ESP devices send data in a format that can be easily parsed, like JSON or key-value pairs.</p><p>For example, the DevKit could send: “temperature=25.5”</p><p>Then, Telegraf can use the parser processor to extract the value.</p><p>Wait, actually, for InfluxDB, it’s better to send data in line protocol format directly from the ESP, but since I’m using C code, it might be simpler to send a simple string and let Telegraf handle the parsing.</p><p>Alternatively, I can write the C code to format the data in line protocol.</p><p>For example, the ESP could send: “sensors,device=devkit temperature=25.5”</p><p>Then, Telegraf can directly forward that to InfluxDB.</p><p>Yes, that might be efficient.</p><p>So, in the C code, I’ll format the data as InfluxDB line protocol strings and publish them to MQTT.</p><p>Then, in Telegraf, I can use the inputs.mqtt_consumer plugin with data_format = “influx” to directly parse the messages as line protocol.</p><p>That way, Telegraf can send them straight to InfluxDB without additional processing.</p><p>Perfect.</p><p>Similarly for the CAM, if it’s sending numerical data.</p><p>For example: “sensors,device=cam objects=3”</p><p>So, in the telegraf.conf, I can have:</p><p>toml</p><p>Collapse</p><p>Wrap</p><p>Copy [[inputs.mqtt_consumer]] servers = [“tcp://mosquitto:1883”] topics = [“sensors/#”] data_format = “influx” username = “[[SECRET:docker:mqtt_username]]” password = “[[SECRET:docker:mqtt_password]]”</p><p>[[outputs.influxdb_v2]] urls = [“http://influxdb:8086”] token = “[[SECRET:docker:influxdb_token]]” organization = “myorg” bucket = “mybucket” And define the secret store:</p><p>toml</p><p>Collapse</p><p>Wrap</p><p>Copy [[secretstores.docker]] id = “docker” path = “/run/secrets” Wait, actually, in the Telegraf documentation, the path is optional and defaults to /run/secrets, so I might not need to specify it.</p><p>Let me confirm.</p><p>Upon checking, yes, the default path is /run/secrets, so I can just define:</p><p>toml</p><p>Collapse</p><p>Wrap</p><p>Copy [[secretstores.docker]] id = “docker” Then use [[SECRET:docker:secret_name]].</p><p>Great.</p><p>Now, for the ESP code, I need to use an MQTT library.</p><p>For ESP-IDF, there’s the official MQTT component.</p><p>I can use that to connect to the MQTT broker and publish messages.</p><p>I need to handle WiFi connection, MQTT connection, and publishing.</p><p>Also, for security, I should use username and password for MQTT, which can be stored in the ESP’s NVS (Non-Volatile Storage) or hardcoded (though less secure).</p><p>But since this is a prototype, I might hardcode them for now.</p><p>Alternatively, I can use provisioning methods, but that might be overkill.</p><p>So, in summary:</p><p>Write C code for ESP32 DevKit and CAM to connect to WiFi, connect to MQTT with credentials, and publish data in InfluxDB line protocol format. Set up Docker Compose with Mosquitto, InfluxDB, Telegraf, and Grafana. Use Docker secrets to manage credentials for MQTT and InfluxDB. Configure Telegraf to use the Docker secret store and subscribe to MQTT topics, forwarding data to InfluxDB. Set up Grafana to connect to InfluxDB and create dashboards. Additionally, I might want to add persistence for InfluxDB and Grafana data, so I don’t lose data on container restarts.</p><p>In the Docker Compose file, I already have volumes defined for that.</p><p>Also, for Mosquitto, I might want to configure it to require authentication.</p><p>I can create a mosquitto.conf file and a password file.</p><p>For example, in ./mosquitto/config/mosquitto.conf:</p><p>text</p><p>Collapse</p><p>Wrap</p><p>Copy allow_anonymous false password_file /mosquitto/config/passwordfile Then, create a password file with usernames and hashed passwords.</p><p>I can use the mosquitto_passwd utility to create the password file.</p><p>Alternatively, since I’m using Docker secrets, I might be able to manage the password file as a secret.</p><p>But for simplicity, I can create the password file on the host and mount it into the container.</p><p>Wait, actually, to make it more secure, I can generate the password file and store it as a secret.</p><p>But perhaps it’s easier to manage it as a file.</p><p>Let me think.</p><p>In the web results, there’s an example where the MQTT password is stored as a secret, and then used in the Telegraf configuration.</p><p>Similarly, for Mosquitto, I can configure it to use a password file, and mount that file from a secret.</p><p>Wait, in Docker Compose, secrets are mounted as files, so I can define a secret for the password file and mount it into Mosquitto.</p><p>For example:</p><p>In docker-compose.yml:</p><p>yaml</p><p>Collapse</p><p>Wrap</p><p>Copy secrets: mqtt_passwordfile: file: ./secrets/mqtt_passwordfile.txt</p><p>services: mosquitto: image: eclipse-mosquitto ports: - “1883:1883” volumes: - ./mosquitto/config/mosquitto.conf:/mosquitto/config/mosquitto.conf secrets: - mqtt_passwordfile Then, in mosquitto.conf:</p><p>text</p><p>Collapse</p><p>Wrap</p><p>Copy allow_anonymous false password_file /run/secrets/mqtt_passwordfile Yes, that should work.</p><p>So, I need to create the mqtt_passwordfile.txt with the username and hashed password.</p><p>I can use mosquitto_passwd to create it.</p><p>For example, run:</p><p>sh</p><p>Collapse</p><p>Wrap</p><p>Copy docker run –rm -it eclipse-mosquitto mosquitto_passwd -c /tmp/passwordfile myuser Then, copy the /tmp/passwordfile to ./secrets/mqtt_passwordfile.txt.</p><p>Alternatively, I can run mosquitto_passwd on the host if I have it installed.</p><p>Once that’s set up, the ESP devices and Telegraf can connect to MQTT with the username and password.</p><p>Similarly, for InfluxDB, I need to set up the initial user, organization, bucket, and token.</p><p>In the Docker Compose file, I can use environment variables to set these, and use secrets for the sensitive parts.</p><p>For example:</p><p>yaml</p><p>Collapse</p><p>Wrap</p><p>Copy services: influxdb: image: influxdb:2.7.1 ports: - “8086:8086” environment: DOCKER_INFLUXDB_INIT_MODE: setup DOCKER_INFLUXDB_INIT_USERNAME_FILE: /run/secrets/influxdb_username DOCKER_INFLUXDB_INIT_PASSWORD_FILE: /run/secrets/influxdb_password DOCKER_INFLUXDB_INIT_ADMIN_TOKEN_FILE: /run/secrets/influxdb_token DOCKER_INFLUXDB_INIT_ORG: myorg DOCKER_INFLUXDB_INIT_BUCKET: mybucket secrets: - influxdb_username - influxdb_password - influxdb_token volumes: - influxdb_data:/var/lib/influxdb2 Then, create the secret files:</p><p>./secrets/influxdb_username.txt: contains the username, e.g., “admin” ./secrets/influxdb_password.txt: contains the password ./secrets/influxdb_token.txt: contains the token, or leave it empty to let InfluxDB generate one Wait, actually, if I don’t specify the token, InfluxDB will generate one.</p><p>But for Telegraf to connect, I need to know the token.</p><p>So, perhaps I can generate the token separately and store it as a secret.</p><p>Alternatively, I can run the InfluxDB container first, get the generated token, and then set it in the Telegraf configuration.</p><p>But that might be manual.</p><p>Wait, in the web results, there’s a way to retrieve the token after setup.</p><p>For example, after starting InfluxDB, I can run a command to get the token.</p><p>But since I’m using Docker Compose, I can perhaps add a step to extract the token and set it as an environment variable or something.</p><p>Alternatively, I can use the same token for both InfluxDB setup and Telegraf.</p><p>Wait, actually, during the initial setup, InfluxDB creates an operator token, which can be used by Telegraf.</p><p>So, if I specify DOCKER_INFLUXDB_INIT_ADMIN_TOKEN_FILE, I can provide a token, and then use the same token in Telegraf.</p><p>For example, create a token and store it in ./secrets/influxdb_token.txt, then reference it in both InfluxDB and Telegraf.</p><p>But how do I generate the token beforehand?</p><p>Perhaps I can generate a random token and use it.</p><p>For example, in a script, generate a token and write it to the secret file.</p><p>Then, use that token in Telegraf.</p><p>Yes, that could work.</p><p>So, before running docker-compose up, I can run a script to generate the secrets, including the InfluxDB token.</p><p>For example:</p><p>sh</p><p>Collapse</p><p>Wrap</p><p>Copy #!/bin/bash</p><h1 id="generate-influxdb-token">Generate InfluxDB token</h1><p>INFLUXDB_TOKEN=$(openssl rand -base64 32) echo $INFLUXDB_TOKEN &gt; ./secrets/influxdb_token.txt</p><h1 id="set-other-secrets">Set other secrets</h1><p>echo “admin” &gt; ./secrets/influxdb_username.txt echo “password” &gt; ./secrets/influxdb_password.txt echo “mqtt_user” &gt; ./secrets/mqtt_username.txt echo “mqtt_pass” &gt; ./secrets/mqtt_password.txt</p><h1 id="create-mqtt-password-file">Create MQTT password file</h1><p>docker run –rm -it eclipse-mosquitto mosquitto_passwd -b /tmp/passwordfile mqtt_user mqtt_pass cp /tmp/passwordfile ./secrets/mqtt_passwordfile.txt Wait, actually, mosquitto_passwd needs to be run inside the container or on a system with Mosquitto installed.</p><p>Alternatively, I can use a Python script or something to hash the password.</p><p>But for simplicity, perhaps I can hardcode the password file for now.</p><p>Or, since I’m using Docker, I can run a temporary container to generate the password file.</p><p>For example:</p><p>sh</p><p>Collapse</p><p>Wrap</p><p>Copy docker run –rm -v $(pwd)/secrets:/secrets eclipse-mosquitto mosquitto_passwd -c /secrets/mqtt_passwordfile.txt mqtt_user Then, it will prompt for the password, and I can enter it.</p><p>But that’s interactive, which might not be ideal.</p><p>Alternatively, I can use -b to specify the password in the command, but that’s insecure as it exposes the password in the command line.</p><p>Perhaps I can use a script to automate it.</p><p>But let’s assume that I create the password file manually for now.</p><p>So, to summarize the setup process:</p><p>Create secret files: ./secrets/influxdb_username.txt: e.g., “admin” ./secrets/influxdb_password.txt: e.g., “password” ./secrets/influxdb_token.txt: e.g., a random string like “my_secure_token” ./secrets/mqtt_username.txt: e.g., “mqtt_user” ./secrets/mqtt_password.txt: e.g., “mqtt_pass” ./secrets/mqtt_passwordfile.txt: the Mosquitto password file with hashed password Create mosquitto.conf in ./mosquitto/config/mosquitto.conf: text</p><p>Collapse</p><p>Wrap</p><p>Copy allow_anonymous false password_file /run/secrets/mqtt_passwordfile Create telegraf.conf with the secret store and input/output plugins as above. Write the docker-compose.yml file as outlined. For the ESP devices, write C code to connect to WiFi, connect to MQTT with username “mqtt_user” and password “mqtt_pass”, and publish data in InfluxDB line protocol format to topics like “sensors/devkit” or “sensors/cam”. Start the Docker Compose stack: docker-compose up -d Access Grafana at http://localhost:3000, log in with default credentials (admin/admin), and set up the InfluxDB data source using the token. Wait, for Grafana, I need to configure it to connect to InfluxDB.</p><p>Since InfluxDB 2.x uses tokens, I need to provide the token to Grafana.</p><p>I can do this manually after starting the stack, or I can provision Grafana with a data source configuration.</p><p>For example, I can create a grafana/provisioning/datasources/influxdb.yml file:</p><p>yaml</p><p>Collapse</p><p>Wrap</p><p>Copy apiVersion: 1</p><p>datasources:</p><ul><li>name: InfluxDB type: influxdb access: proxy url: http://influxdb:8086 jsonData: version: Flux organization: myorg defaultBucket: mybucket secureJsonData: token: my_secure_token Then, in the Docker Compose file, mount this configuration:</ul><p>yaml</p><p>Collapse</p><p>Wrap</p><p>Copy grafana: image: grafana/grafana:9.5.12 ports: - “3000:3000” volumes: - grafana_data:/var/lib/grafana - ./grafana/provisioning:/etc/grafana/provisioning environment: GF_SECURITY_ADMIN_USER: admin GF_SECURITY_ADMIN_PASSWORD: admin But wait, the token is sensitive, so I shouldn’t hardcode it in the configuration file.</p><p>Alternatively, I can use environment variables in Grafana to set the token.</p><p>But checking the Grafana documentation, it seems that for provisioning, the secureJsonData is used for sensitive information, but it’s still stored in the file.</p><p>Perhaps for a production setup, I need to handle it differently, but for this prototype, I can accept that the token is in the configuration file.</p><p>Alternatively, I can use a script to replace placeholders in the configuration file with the actual token from the secret.</p><p>But that might be overkill.</p><p>For now, I’ll assume that I manually configure Grafana after starting the stack.</p><p>So, after starting Docker Compose, I can access Grafana, add the InfluxDB data source, and input the token manually.</p><p>Later, I can automate it if needed.</p><p>Therefore, the final setup is:</p><p>ESP controllers programmed in C to send data via MQTT in InfluxDB line protocol. Docker Compose stack with Mosquitto, InfluxDB, Telegraf, and Grafana. Docker secrets used for credentials. Telegraf configured to use Docker secrets for MQTT and InfluxDB credentials. Grafana manually configured to connect to InfluxDB. This should provide a secure and functional IoT stack.</p><p>I think that covers the main points.</p><p>Let me just check if there’s anything missing.</p><p>Ah, for the CAM, if I want to handle images, I might need additional components, like a web server to receive image uploads, but as mentioned earlier, for simplicity, I’ll assume it’s sending numerical data via MQTT.</p><p>If needed, I can extend the stack later.</p><p>Also, I should ensure that the ESP devices can connect to the MQTT broker running in Docker.</p><p>Since the broker is exposed on port 1883, and assuming the Docker host is accessible from the ESP devices, it should be fine.</p><p>I might need to use the Docker host’s IP address in the ESP code.</p><p>Alternatively, if the ESP devices are on the same network, I can use mDNS or something, but for simplicity, I’ll hardcode the IP.</p><p>Moreover, for production, I should consider security aspects like TLS for MQTT, but that complicates the setup, so I’ll leave it for now.</p><p>In conclusion, this setup should work well for an IoT project with ESP controllers, using InfluxDB, Telegraf, and Grafana, all managed with Docker Compose and Docker secrets for secure credential handling.</p><p>Based on the requirements for your IoT project, I’ve designed a technology stack that integrates ESP controllers (DevKit and CAM) with InfluxDB, Telegraf, and Grafana, all managed through Docker Compose with Docker secrets for secure credential handling. This setup ensures that your IoT data is collected, stored, and visualized efficiently while maintaining security best practices.</p><p>Overview of the Technology Stack ESP Controllers (DevKit and CAM): Programmed in C using the ESP-IDF framework to collect sensor data (e.g., temperature from DevKit) and other metrics (e.g., object detection counts from CAM). The data is published to an MQTT broker. Docker Compose: Manages the containerized services, including Mosquitto (MQTT broker), InfluxDB (time-series database), Telegraf (data collection agent), and Grafana (visualization tool). Docker Secrets: Securely handles sensitive credentials such as MQTT passwords and InfluxDB tokens, ensuring they are not exposed in environment variables or configuration files. Step-by-Step Setup</p><ol><li>ESP Controllers (DevKit and CAM) Programming: Use C code with the ESP-IDF framework to program the ESP32-based DevKit and CAM. DevKit: Collect sensor data (e.g., temperature) and publish it to an MQTT topic (e.g., “sensors/devkit”). CAM: For simplicity, send numerical data (e.g., object detection counts) to an MQTT topic (e.g., “sensors/cam”). If needed, image handling can be added later. Data Format: Format the data in InfluxDB’s line protocol before publishing to MQTT. For example: DevKit: “sensors,device=devkit temperature=25.5” CAM: “sensors,device=cam objects=3” MQTT Connection: Connect to the MQTT broker using a username and password for secure access.<li>Docker Compose Setup The entire server-side stack is containerized and managed via Docker Compose. Below is an outline of the services and their configurations:</ol><p>Mosquitto (MQTT Broker): Handles communication between ESP devices and the server. Configured to require authentication using a password file managed via Docker secrets. InfluxDB: Stores time-series data from the ESP devices. Initialized with a secure admin username, password, and token using Docker secrets. Telegraf: Collects data from MQTT topics and forwards it to InfluxDB. Uses Docker secrets to securely access MQTT and InfluxDB credentials. Grafana: Visualizes the data stored in InfluxDB. Manually configured to connect to InfluxDB using the admin token.</p><ol><li>Secure Credential Management with Docker Secrets Secrets: influxdb_username, influxdb_password, influxdb_token: For InfluxDB admin access. mqtt_username, mqtt_password: For MQTT authentication. mqtt_passwordfile: Mosquitto password file for secure authentication. Usage: Secrets are mounted into the containers as files (e.g., /run/secrets/influxdb_token). Telegraf uses its Docker secret store plugin to access these secrets without exposing them in configuration files.<li>Configuration Files Mosquitto Configuration (mosquitto.conf): Disallows anonymous access and uses a password file from Docker secrets. Telegraf Configuration (telegraf.conf): Configures the Docker secret store to access MQTT and InfluxDB credentials. Subscribes to MQTT topics and forwards data directly to InfluxDB using the influx data format.<li>Running the Stack Start the Stack: Use docker-compose up -d to launch all services. Access Grafana: Visit http://localhost:3000, log in with default credentials (e.g., admin/admin), and manually add InfluxDB as a data source using the admin token. Visualize Data: Create dashboards in Grafana to monitor the IoT data in real-time. Benefits of This Stack Scalability: Docker Compose makes it easy to manage and scale the services. Security: Docker secrets ensure that sensitive credentials are handled securely. Efficiency: Telegraf efficiently collects and forwards data to InfluxDB, while Grafana provides powerful visualization tools. Flexibility: The stack can be extended to include additional services (e.g., for image handling) as needed. This setup provides a robust, secure, and efficient solution for your IoT project, leveraging the strengths of each component while ensuring ease of management through Docker Compose.</ol><h1 id="lets-buid-it-with-some-requirements">Let’s buid it with some requirements</h1><p>Based on your requirements for an IoT project using ESP controllers (DevKit and CAM), C code, InfluxDB, Telegraf, Grafana, and a Docker Compose setup with Docker secrets, I’ve designed a complete technology stack that meets your needs. Below is a detailed, self-contained guide to set up this project, ensuring it works seamlessly for data collection, storage, and visualization while maintaining security through Docker secrets.</p><hr /><h3 id="technology-stack-overview"><span class="mr-2">Technology Stack Overview</span><a href="#technology-stack-overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>This stack integrates ESP controllers with a server-side setup running in Docker containers. Here’s how each component fits together:</p><ul><li><strong>ESP Controllers (DevKit and CAM)</strong>:<ul><li>Programmed in C using the ESP-IDF framework.<li>Collect data (e.g., temperature from DevKit, object counts from CAM) and send it to an MQTT broker.</ul><li><strong>Docker Compose Services</strong>:<ul><li><strong>Mosquitto</strong>: An MQTT broker to handle communication between ESP devices and the server.<li><strong>InfluxDB</strong>: A time-series database to store IoT data.<li><strong>Telegraf</strong>: A data collection agent that subscribes to MQTT topics and forwards data to InfluxDB.<li><strong>Grafana</strong>: A visualization tool to create dashboards from InfluxDB data.</ul><li><strong>Docker Secrets</strong>: Securely manages sensitive credentials like MQTT passwords and InfluxDB tokens.</ul><hr /><h3 id="step-by-step-implementation"><span class="mr-2">Step-by-Step Implementation</span><a href="#step-by-step-implementation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="1-program-the-esp-controllers"><span class="mr-2">1. Program the ESP Controllers</span><a href="#1-program-the-esp-controllers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>You’ll use C code with the ESP-IDF framework to program the ESP32-based DevKit and CAM controllers.</p><ul><li><strong>ESP32 DevKit</strong>:<ul><li><strong>Purpose</strong>: Collect sensor data (e.g., temperature).<li><strong>Action</strong>: Read data from a sensor (e.g., a temperature sensor) and publish it to an MQTT topic like <code class="language-plaintext highlighter-rouge">"sensors/devkit"</code>.<li><strong>Example Data</strong>: <code class="language-plaintext highlighter-rouge">"sensors,device=devkit temperature=25.5"</code>.</ul><li><strong>ESP32 CAM</strong>:<ul><li><strong>Purpose</strong>: For simplicity, send numerical data (e.g., number of detected objects) rather than full images.<li><strong>Action</strong>: Publish data to an MQTT topic like <code class="language-plaintext highlighter-rouge">"sensors/cam"</code>.<li><strong>Example Data</strong>: <code class="language-plaintext highlighter-rouge">"sensors,device=cam objects=3"</code>.</ul><li><strong>Implementation</strong>:<ul><li>Use the ESP-IDF MQTT component to connect to the MQTT broker (e.g., running on your Docker host at port 1883).<li>Format data in <strong>InfluxDB line protocol</strong> (as shown above) to simplify processing by Telegraf.<li>Configure WiFi and MQTT credentials (username: <code class="language-plaintext highlighter-rouge">mqtt_user</code>, password: <code class="language-plaintext highlighter-rouge">mqtt_pass</code>) in your C code. For a prototype, these can be hardcoded, but consider using NVS (Non-Volatile Storage) for a more secure setup later.</ul><li><strong>Sample C Code Outline</strong>:<div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"mqtt_client.h"</span><span class="cp">
</span><span class="k">static</span> <span class="n">esp_mqtt_client_handle_t</span> <span class="n">client</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">mqtt_event_handler</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handler_args</span><span class="p">,</span> <span class="n">esp_event_base_t</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">event_id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">event_data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle MQTT events (e.g., connected, data received)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">app_main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Initialize WiFi</span>
    <span class="c1">// Configure MQTT client</span>
    <span class="n">esp_mqtt_client_config_t</span> <span class="n">mqtt_cfg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">broker</span><span class="p">.</span><span class="n">address</span><span class="p">.</span><span class="n">uri</span> <span class="o">=</span> <span class="s">"mqtt://&lt;docker-host-ip&gt;:1883"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">credentials</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="s">"mqtt_user"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">credentials</span><span class="p">.</span><span class="n">password</span> <span class="o">=</span> <span class="s">"mqtt_pass"</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">esp_mqtt_client_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mqtt_cfg</span><span class="p">);</span>
    <span class="n">esp_mqtt_client_register_event</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">ESP_EVENT_ANY_ID</span><span class="p">,</span> <span class="n">mqtt_event_handler</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">esp_mqtt_client_start</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>

    <span class="c1">// Read sensor data and publish (example)</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="s">"sensors,device=devkit temperature=25.5"</span><span class="p">);</span>
    <span class="n">esp_mqtt_client_publish</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="s">"sensors/devkit"</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div></ul><h4 id="2-set-up-docker-compose"><span class="mr-2">2. Set Up Docker Compose</span><a href="#2-set-up-docker-compose" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>The server-side stack runs in Docker containers managed by a <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> file. Create this file with the following content:</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre><td class="rouge-code"><pre><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>

<span class="na">secrets</span><span class="pi">:</span>
  <span class="na">influxdb_username</span><span class="pi">:</span>
    <span class="na">file</span><span class="pi">:</span> <span class="s">./secrets/influxdb_username.txt</span>
  <span class="na">influxdb_password</span><span class="pi">:</span>
    <span class="na">file</span><span class="pi">:</span> <span class="s">./secrets/influxdb_password.txt</span>
  <span class="na">influxdb_token</span><span class="pi">:</span>
    <span class="na">file</span><span class="pi">:</span> <span class="s">./secrets/influxdb_token.txt</span>
  <span class="na">mqtt_username</span><span class="pi">:</span>
    <span class="na">file</span><span class="pi">:</span> <span class="s">./secrets/mqtt_username.txt</span>
  <span class="na">mqtt_password</span><span class="pi">:</span>
    <span class="na">file</span><span class="pi">:</span> <span class="s">./secrets/mqtt_password.txt</span>
  <span class="na">mqtt_passwordfile</span><span class="pi">:</span>
    <span class="na">file</span><span class="pi">:</span> <span class="s">./secrets/mqtt_passwordfile.txt</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">mosquitto</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">eclipse-mosquitto:latest</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">1883:1883"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./mosquitto/config/mosquitto.conf:/mosquitto/config/mosquitto.conf</span>
    <span class="na">secrets</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mqtt_passwordfile</span>

  <span class="na">influxdb</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">influxdb:2.7.1</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8086:8086"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">influxdb_data:/var/lib/influxdb2</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">DOCKER_INFLUXDB_INIT_MODE</span><span class="pi">:</span> <span class="s">setup</span>
      <span class="na">DOCKER_INFLUXDB_INIT_USERNAME_FILE</span><span class="pi">:</span> <span class="s">/run/secrets/influxdb_username</span>
      <span class="na">DOCKER_INFLUXDB_INIT_PASSWORD_FILE</span><span class="pi">:</span> <span class="s">/run/secrets/influxdb_password</span>
      <span class="na">DOCKER_INFLUXDB_INIT_ADMIN_TOKEN_FILE</span><span class="pi">:</span> <span class="s">/run/secrets/influxdb_token</span>
      <span class="na">DOCKER_INFLUXDB_INIT_ORG</span><span class="pi">:</span> <span class="s">myorg</span>
      <span class="na">DOCKER_INFLUXDB_INIT_BUCKET</span><span class="pi">:</span> <span class="s">mybucket</span>
    <span class="na">secrets</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">influxdb_username</span>
      <span class="pi">-</span> <span class="s">influxdb_password</span>
      <span class="pi">-</span> <span class="s">influxdb_token</span>

  <span class="na">telegraf</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">telegraf:1.28</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./telegraf/telegraf.conf:/etc/telegraf/telegraf.conf:ro</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mosquitto</span>
      <span class="pi">-</span> <span class="s">influxdb</span>
    <span class="na">secrets</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mqtt_username</span>
      <span class="pi">-</span> <span class="s">mqtt_password</span>
      <span class="pi">-</span> <span class="s">influxdb_token</span>

  <span class="na">grafana</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">grafana/grafana:9.5.12</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">3000:3000"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">grafana_data:/var/lib/grafana</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">influxdb</span>

<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">influxdb_data</span><span class="pi">:</span>
  <span class="na">grafana_data</span><span class="pi">:</span>
</pre></table></code></div></div><ul><li><strong>Notes</strong>:<ul><li>Replace <code class="language-plaintext highlighter-rouge">&lt;docker-host-ip&gt;</code> in the ESP code with the actual IP address of your Docker host.<li>Volumes ensure data persistence for InfluxDB and Grafana.</ul></ul><h4 id="3-configure-mosquitto"><span class="mr-2">3. Configure Mosquitto</span><a href="#3-configure-mosquitto" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Create a <code class="language-plaintext highlighter-rouge">mosquitto.conf</code> file in <code class="language-plaintext highlighter-rouge">./mosquitto/config/</code>:<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>allow_anonymous false
password_file /run/secrets/mqtt_passwordfile
</pre></table></code></div></div><li>This enforces authentication using a password file managed as a Docker secret.</ul><h4 id="4-configure-telegraf"><span class="mr-2">4. Configure Telegraf</span><a href="#4-configure-telegraf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Create a <code class="language-plaintext highlighter-rouge">telegraf.conf</code> file in <code class="language-plaintext highlighter-rouge">./telegraf/</code>:<div class="language-toml highlighter-rouge"><div class="code-header"> <span data-label-text="TOML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nn">[[secretstores.docker]]</span>
  <span class="py">id</span> <span class="p">=</span> <span class="s">"docker"</span>

<span class="nn">[[inputs.mqtt_consumer]]</span>
  <span class="py">servers</span> <span class="p">=</span> <span class="nn">["tcp://mosquitto:1883"]</span>
  <span class="py">topics</span> <span class="p">=</span> <span class="nn">["sensors/#"]</span>
  <span class="py">data_format</span> <span class="p">=</span> <span class="s">"influx"</span>
  <span class="py">username</span> <span class="p">=</span> <span class="s">"[[SECRET:docker:mqtt_username]]"</span>
  <span class="py">password</span> <span class="p">=</span> <span class="s">"[[SECRET:docker:mqtt_password]]"</span>

<span class="nn">[[outputs.influxdb_v2]]</span>
  <span class="py">urls</span> <span class="p">=</span> <span class="nn">["http://influxdb:8086"]</span>
  <span class="py">token</span> <span class="p">=</span> <span class="s">"[[SECRET:docker:influxdb_token]]"</span>
  <span class="py">organization</span> <span class="p">=</span> <span class="s">"myorg"</span>
  <span class="py">bucket</span> <span class="p">=</span> <span class="s">"mybucket"</span>
</pre></table></code></div></div><li><strong>Explanation</strong>:<ul><li>The <code class="language-plaintext highlighter-rouge">secretstores.docker</code> section enables Telegraf to read Docker secrets from <code class="language-plaintext highlighter-rouge">/run/secrets/</code>.<li>The <code class="language-plaintext highlighter-rouge">inputs.mqtt_consumer</code> plugin subscribes to MQTT topics and parses data in InfluxDB line protocol format.<li>The <code class="language-plaintext highlighter-rouge">outputs.influxdb_v2</code> plugin sends data to InfluxDB using the admin token.</ul></ul><h4 id="5-prepare-docker-secrets"><span class="mr-2">5. Prepare Docker Secrets</span><a href="#5-prepare-docker-secrets" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Create a <code class="language-plaintext highlighter-rouge">secrets/</code> directory and populate the secret files:<ul><li><code class="language-plaintext highlighter-rouge">influxdb_username.txt</code>: <code class="language-plaintext highlighter-rouge">admin</code><li><code class="language-plaintext highlighter-rouge">influxdb_password.txt</code>: <code class="language-plaintext highlighter-rouge">password123</code><li><code class="language-plaintext highlighter-rouge">influxdb_token.txt</code>: <code class="language-plaintext highlighter-rouge">my_secure_token</code> (or generate a random string, e.g., via <code class="language-plaintext highlighter-rouge">openssl rand -base64 32</code>)<li><code class="language-plaintext highlighter-rouge">mqtt_username.txt</code>: <code class="language-plaintext highlighter-rouge">mqtt_user</code><li><code class="language-plaintext highlighter-rouge">mqtt_password.txt</code>: <code class="language-plaintext highlighter-rouge">mqtt_pass</code><li><code class="language-plaintext highlighter-rouge">mqtt_passwordfile.txt</code>: A Mosquitto password file with the hashed password for <code class="language-plaintext highlighter-rouge">mqtt_user</code>.</ul><li><strong>Generate the MQTT Password File</strong>: Run this command to create the password file (requires Mosquitto installed locally or use a Docker container):<div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker run <span class="nt">--rm</span> <span class="nt">-v</span> <span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>/secrets:/secrets eclipse-mosquitto mosquitto_passwd <span class="nt">-c</span> /secrets/mqtt_passwordfile.txt mqtt_user mqtt_pass
</pre></table></code></div></div></ul><h4 id="6-launch-the-stack"><span class="mr-2">6. Launch the Stack</span><a href="#6-launch-the-stack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Run the Docker Compose stack:<div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker-compose up <span class="nt">-d</span>
</pre></table></code></div></div><li>This starts all services in the background.</ul><h4 id="7-configure-grafana"><span class="mr-2">7. Configure Grafana</span><a href="#7-configure-grafana" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Access Grafana at <code class="language-plaintext highlighter-rouge">http://localhost:3000</code>.<li>Log in with default credentials (admin/admin).<li>Add an InfluxDB data source:<ul><li><strong>URL</strong>: <code class="language-plaintext highlighter-rouge">http://influxdb:8086</code><li><strong>Organization</strong>: <code class="language-plaintext highlighter-rouge">myorg</code><li><strong>Bucket</strong>: <code class="language-plaintext highlighter-rouge">mybucket</code><li><strong>Token</strong>: Copy the value from <code class="language-plaintext highlighter-rouge">secrets/influxdb_token.txt</code> (e.g., <code class="language-plaintext highlighter-rouge">my_secure_token</code>).</ul><li>Create dashboards to visualize your IoT data (e.g., temperature trends from DevKit, object counts from CAM).</ul><hr /><h3 id="how-it-all-works-together"><span class="mr-2">How It All Works Together</span><a href="#how-it-all-works-together" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ol><li><strong>ESP Controllers</strong>:<ul><li>Publish data in InfluxDB line protocol to MQTT topics (e.g., <code class="language-plaintext highlighter-rouge">"sensors/devkit"</code>, <code class="language-plaintext highlighter-rouge">"sensors/cam"</code>).</ul><li><strong>Mosquitto</strong>:<ul><li>Receives MQTT messages from the ESP devices and enforces authentication.</ul><li><strong>Telegraf</strong>:<ul><li>Subscribes to MQTT topics, parses the line protocol data, and forwards it to InfluxDB using secure credentials from Docker secrets.</ul><li><strong>InfluxDB</strong>:<ul><li>Stores the time-series data in the <code class="language-plaintext highlighter-rouge">mybucket</code> bucket.</ul><li><strong>Grafana</strong>:<ul><li>Queries InfluxDB to display the data in real-time dashboards.</ul></ol><hr /><h3 id="additional-notes"><span class="mr-2">Additional Notes</span><a href="#additional-notes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>Security</strong>: For a production setup, consider adding TLS for MQTT and InfluxDB. This prototype uses plain text for simplicity.<li><strong>ESP Connectivity</strong>: Ensure your ESP devices can reach the Docker host’s IP on port 1883.<li><strong>Extending the Stack</strong>: If you need to handle images from the ESP32 CAM, add a web server service to the Docker Compose file and adjust the ESP code to upload images via HTTP.</ul><p>This setup provides a robust, secure, and efficient IoT solution that leverages InfluxDB, Telegraf, Grafana, and ESP controllers, all managed seamlessly with Docker Compose and Docker secrets. Let me know if you need further clarification!</p><h1 id="what-we-can-do-with-small-budget">What we can do with small budget</h1><h2 id="thinking-"><span class="mr-2">Thinking …</span><a href="#thinking-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Alright, let’s break this down. I need to choose a technology stack for an IoT project, and I’m on a tight budget. That means I have to be smart about what I pick—something that’s cost-effective but still reliable and scalable. Let’s think through the key components I’ll need:</p><p>Hardware: I’ll need IoT devices to collect data. Since I’m on a budget, I should look for affordable yet capable hardware. Something like Raspberry Pi or Arduino boards could work. Raspberry Pi is a bit more powerful and can handle more complex tasks, but Arduino is cheaper and great for simpler sensor-based projects. I should decide based on the specific needs of my project. Connectivity: How will my devices connect to the internet or to each other? Wi-Fi is common, but it can be power-hungry. If my devices are battery-powered, I might want to consider low-power options like LoRaWAN or Zigbee. However, these might require additional hardware like gateways, which could add to the cost. Bluetooth Low Energy (BLE) is another option for short-range communication. Data Storage and Processing: I need a place to store the data my devices collect. Cloud services are convenient, but they can get expensive with lots of data. Since I’m on a budget, I might want to consider self-hosting a database on a local server or using a low-cost cloud provider. For processing, I could use something like Node-RED for simple automation or a more robust platform like AWS IoT or Google Cloud IoT if I need more features. Security: IoT devices can be vulnerable to attacks, so I need to make sure my stack includes good security practices. This might include encrypted communication, secure authentication, and regular updates. Since I’m on a budget, I might need to handle some of this myself rather than relying on expensive managed services. Scalability: Even though I’m starting small, I should think about whether my stack can scale if my project grows. Using open-source software and modular hardware can help with this. Let me consider a specific example to make this more concrete. Suppose I want to build a smart home system that monitors temperature and humidity in different rooms. Here’s how I might approach it:</p><p>Hardware: I’d use Arduino boards with temperature and humidity sensors. They’re cheap and easy to program. Connectivity: Since it’s a home environment, Wi-Fi should be fine. I can use the ESP8266 module with Arduino for Wi-Fi connectivity. Data Storage and Processing: I could set up a local server using a Raspberry Pi to collect data from the Arduino boards. I’d use a lightweight database like SQLite or InfluxDB to store the data. For processing, I could use Node-RED to create simple automation rules, like sending an alert if the temperature gets too high. Security: I’d make sure to secure the Wi-Fi network with a strong password and use HTTPS for any web interfaces. I’d also keep the software up to date to patch any vulnerabilities. Scalability: If I want to add more sensors or rooms, I can easily add more Arduino boards and update the Node-RED flows. This seems like a solid, budget-friendly stack for a simple IoT project. But let’s think about whether there are even cheaper or more efficient options.</p><p>Another approach could be to use ESP32 boards, which have built-in Wi-Fi and are more powerful than Arduino. They’re a bit more expensive, but they might simplify the setup since I wouldn’t need separate Wi-Fi modules. Plus, they can run more complex code, which could be useful if my project grows.</p><p>For data storage, I could consider using a cloud service with a free tier, like AWS IoT Core or Google Cloud IoT Core. These offer basic features for free, which could be enough for a small project. However, I need to be careful about potential costs if my usage exceeds the free tier limits.</p><p>Wait a minute, since I’m on a tight budget, I should probably avoid cloud services altogether to prevent unexpected costs. Self-hosting on a local server is more predictable in terms of cost, even if it requires a bit more setup.</p><p>Let me also consider the software side. For the local server, I could use a Linux-based OS on the Raspberry Pi, which is free. Then, I can install open-source software like Mosquitto for MQTT communication, InfluxDB for time-series data storage, and Grafana for visualization. All of these are free and widely used in IoT projects.</p><p>MQTT is a lightweight messaging protocol that’s perfect for IoT devices with limited resources. It allows my devices to publish data to a broker, and then other services can subscribe to that data. This decouples the devices from the data processing, which is good for scalability.</p><p>So, to summarize, here’s a potential stack:</p><p>Hardware: ESP32 boards with sensors Connectivity: Wi-Fi, using MQTT for communication Data Storage: InfluxDB on a Raspberry Pi Data Processing: Node-RED for automation Visualization: Grafana for dashboards Security: Secure Wi-Fi, encrypted communication (e.g., TLS for MQTT), regular updates This stack is cost-effective because:</p><p>ESP32 boards are relatively cheap. Raspberry Pi is affordable and can serve multiple purposes. All software is open-source and free. No ongoing cloud costs. However, I should consider the time and effort required to set this up. Since I’m on a budget, I might be doing most of the work myself, so I need to make sure I have the necessary skills or the willingness to learn.</p><p>Alternatively, if I’m not comfortable with setting up a local server, I could look into IoT platforms that offer low-cost or free tiers. For example, Blynk is a popular platform for DIY IoT projects that offers a free tier with limited features. It provides a mobile app for controlling and monitoring devices, which could save me the trouble of building my own interface.</p><p>But again, with a tight budget, I need to be cautious about potential costs. Some platforms might charge based on the number of devices or data usage, which could add up.</p><p>Let me think about another option: using a microcontroller with built-in cloud connectivity. For instance, Particle.io offers devices that connect directly to their cloud platform. They have a free tier for up to 100 devices, which might be sufficient for a small project. However, their hardware is more expensive than ESP32 or Arduino, so the initial cost might be higher.</p><p>Wait, actually, upon checking, Particle.io’s Photon board is around $19, which is comparable to an ESP32. But I think their free tier has limitations on data usage or features, so I need to check the details.</p><p>Upon further reflection, I realize that for a truly budget-friendly solution, sticking with open-source hardware and software is probably the best bet. It gives me full control and avoids any subscription fees.</p><p>One more thing to consider is power consumption. If my devices are battery-powered, I need to choose hardware and connectivity options that are energy-efficient. For example, using BLE or LoRaWAN instead of Wi-Fi could extend battery life significantly. However, this might require additional hardware, like a gateway, which could increase costs.</p><p>In my smart home example, since the devices can be plugged in or use rechargeable batteries, Wi-Fi should be fine.</p><p>Let me also think about the development tools. For programming the ESP32, I can use the Arduino IDE or the ESP-IDF framework. Both are free, and there are plenty of tutorials and libraries available.</p><p>For the Raspberry Pi, I can use Raspbian OS, which is also free.</p><p>So, in terms of software development, there are no additional costs.</p><p>Wait, actually, if I choose to use a paid IDE or development tools, that could add to the cost. But since there are free options available, I can avoid that.</p><p>Another aspect is maintenance. Over time, I might need to update the software or replace hardware components. With a self-hosted solution, I’m responsible for maintenance, which could require time and effort. But since it’s a small project, it should be manageable.</p><p>In contrast, with a cloud-based platform, the provider handles maintenance, but I might have less control and could face costs if I need to scale.</p><p>Given all this, I think the most budget-friendly technology stack for my IoT project is:</p><p>Hardware: ESP32 boards with appropriate sensors Connectivity: Wi-Fi with MQTT protocol Data Storage: InfluxDB on a Raspberry Pi Data Processing: Node-RED Visualization: Grafana Security: Implement best practices like secure passwords, encryption, and regular updates This stack leverages affordable hardware, free and open-source software, and avoids ongoing cloud costs. It also provides a good balance between functionality and complexity, making it suitable for a small budget project.</p><p>Of course, the exact choice might vary depending on the specific requirements of the project. For instance, if I need to cover a large area, I might need to consider different connectivity options. Or if the project involves real-time control, I might need a different processing setup.</p><p>But for a general IoT project on a tight budget, this stack should work well.</p><p>Wait, one more thing: I should consider the cost of the Raspberry Pi. While it’s affordable, if I already have an old computer or a low-cost server, I could use that instead to save money. But for most people, a Raspberry Pi is a cost-effective choice.</p><p>Alternatively, if the project is very small, I could even run the server software on my personal computer, but that might not be practical for continuous operation.</p><p>In conclusion, by carefully selecting hardware and software components that are affordable and open-source, I can build a functional IoT system without breaking the bank.</p><p>For an IoT project on a tight budget, the most cost-effective technology stack leverages affordable hardware, open-source software, and self-hosted solutions to avoid ongoing cloud fees. Below is a recommended stack that balances functionality, scalability, and minimal costs:</p><p>Recommended Technology Stack Hardware: ESP32 boards (or Arduino with ESP8266 for Wi-Fi) Affordable, widely used, and capable of handling various sensors (e.g., temperature, humidity). ESP32 offers built-in Wi-Fi and more processing power than basic Arduino boards. Connectivity: Wi-Fi with MQTT protocol Wi-Fi is suitable for most environments (e.g., home, office). MQTT is lightweight, efficient for IoT devices, and works well with limited resources. For battery-powered devices, consider BLE or LoRaWAN (though they may require additional hardware like gateways). Data Storage: InfluxDB (self-hosted on a Raspberry Pi or low-cost server) A free, open-source time-series database optimized for IoT data. Alternatives: SQLite (for smaller projects) or PostgreSQL. Data Processing: Node-RED A free, open-source tool for wiring together devices, APIs, and services. Ideal for simple automation and data flow management. Visualization: Grafana A free, open-source platform for creating dashboards to monitor and visualize IoT data. Security: Implement best practices: Secure Wi-Fi with strong passwords. Use TLS for encrypted MQTT communication. Regularly update software and firmware. Why This Stack? Cost-Effective Hardware: ESP32 boards are inexpensive (~$5–$10) and versatile. No Cloud Fees: Self-hosting on a Raspberry Pi (~$35–$50) or an existing computer avoids subscription costs. Open-Source Software: InfluxDB, Node-RED, and Grafana are free, widely supported, and scalable. Scalability: Easily add more devices or sensors without significant cost increases. Security: Basic security measures can be implemented without additional cost. Example Project: Smart Home Monitoring Devices: ESP32 boards with temperature/humidity sensors. Connectivity: Wi-Fi + MQTT to publish sensor data. Storage: InfluxDB on a Raspberry Pi to store time-series data. Processing: Node-RED for automation (e.g., alerts if temperature exceeds a threshold). Visualization: Grafana dashboards to monitor room conditions. Alternatives (If Needed) Cloud Services: Use free tiers of AWS IoT Core or Google Cloud IoT for small-scale projects, but monitor usage to avoid unexpected costs. Platforms: Blynk or Particle.io offer free tiers but may have limitations on devices or data. This stack ensures you stay within budget while building a reliable, scalable IoT system. Adjust based on specific project needs, such as power constraints or coverage area.</p><h2 id="recommendation"><span class="mr-2">Recommendation</span><a href="#recommendation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Thanks for sharing your thoughts! Using a home server with Docker Compose to host your services, including Telegraf, is a fantastic idea for your IoT project. It’s a cost-effective and flexible approach that aligns well with managing services on a budget. Let’s break down why this works and go over some key considerations to ensure everything runs smoothly.</p><hr /><h3 id="why-this-approach-is-great"><span class="mr-2">Why This Approach is Great</span><a href="#why-this-approach-is-great" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>Cost-Effective</strong>: Hosting on a home server avoids cloud service fees, and Docker Compose simplifies managing multiple services without extra cost or complexity.<li><strong>Modular and Scalable</strong>: Docker Compose lets you define and run multi-container applications, so you can easily add Telegraf or other services as your project evolves.<li><strong>Perfect for IoT Data Collection</strong>: Telegraf is an excellent choice for gathering metrics from IoT devices and sending them to a database like InfluxDB. It supports various input plugins (e.g., MQTT, HTTP), making it adaptable to your devices.</ul><hr /><h3 id="how-to-set-it-up"><span class="mr-2">How to Set It Up</span><a href="#how-to-set-it-up" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Here’s how you can integrate Telegraf into your Docker Compose setup:</p><h4 id="1-adding-telegraf-to-docker-compose"><span class="mr-2">1. <strong>Adding Telegraf to Docker Compose</strong></span><a href="#1-adding-telegraf-to-docker-compose" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>You can define Telegraf as a service in your <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> file. Here’s a basic example including Telegraf, InfluxDB (for storing data), and Grafana (for visualization):</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">influxdb</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">influxdb:2.7</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8086:8086"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">influxdb_data:/var/lib/influxdb2</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">DOCKER_INFLUXDB_INIT_MODE</span><span class="pi">:</span> <span class="s">setup</span>
      <span class="na">DOCKER_INFLUXDB_INIT_USERNAME</span><span class="pi">:</span> <span class="s">admin</span>
      <span class="na">DOCKER_INFLUXDB_INIT_PASSWORD</span><span class="pi">:</span> <span class="s">password</span>
      <span class="na">DOCKER_INFLUXDB_INIT_ORG</span><span class="pi">:</span> <span class="s">myorg</span>
      <span class="na">DOCKER_INFLUXDB_INIT_BUCKET</span><span class="pi">:</span> <span class="s">mybucket</span>

  <span class="na">telegraf</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">telegraf:1.28</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s">host</span>  <span class="c1"># Allows access to your local network</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./telegraf.conf:/etc/telegraf/telegraf.conf:ro</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">influxdb</span>

  <span class="na">grafana</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">grafana/grafana:9.5.12</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">3000:3000"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">grafana_data:/var/lib/grafana</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">influxdb</span>

<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">influxdb_data</span><span class="pi">:</span>
  <span class="na">grafana_data</span><span class="pi">:</span>
</pre></table></code></div></div><ul><li><strong>Notes</strong>:<ul><li>Replace <code class="language-plaintext highlighter-rouge">./telegraf.conf</code> with the path to your Telegraf configuration file (more on this below).<li>Adjust environment variables for InfluxDB as needed—consider using secrets for sensitive data.</ul></ul><h4 id="2-configuring-telegraf"><span class="mr-2">2. <strong>Configuring Telegraf</strong></span><a href="#2-configuring-telegraf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>Telegraf needs a configuration file (<code class="language-plaintext highlighter-rouge">telegraf.conf</code>) to specify what data to collect and where to send it. Here’s an example for IoT devices sending data via MQTT:</p><div class="language-toml highlighter-rouge"><div class="code-header"> <span data-label-text="TOML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nn">[[inputs.mqtt_consumer]]</span>
  <span class="py">servers</span> <span class="p">=</span> <span class="nn">["tcp://&lt;your-mqtt-broker&gt;:1883"]</span>
  <span class="py">topics</span> <span class="p">=</span> <span class="nn">["sensors/#"]</span>
  <span class="py">data_format</span> <span class="p">=</span> <span class="s">"json"</span>  <span class="c"># Match your devices’ data format</span>

<span class="nn">[[outputs.influxdb_v2]]</span>
  <span class="py">urls</span> <span class="p">=</span> <span class="nn">["http://influxdb:8086"]</span>
  <span class="py">token</span> <span class="p">=</span> <span class="s">"$INFLUX_TOKEN"</span>
  <span class="py">organization</span> <span class="p">=</span> <span class="s">"myorg"</span>
  <span class="py">bucket</span> <span class="p">=</span> <span class="s">"mybucket"</span>
</pre></table></code></div></div><ul><li><strong>Input Plugins</strong>: Choose plugins based on your IoT devices. For example:<ul><li>MQTT: <code class="language-plaintext highlighter-rouge">inputs.mqtt_consumer</code><li>HTTP: <code class="language-plaintext highlighter-rouge">inputs.http_listener_v2</code></ul><li><strong>Output Plugins</strong>: Use <code class="language-plaintext highlighter-rouge">outputs.influxdb_v2</code> to send data to InfluxDB.</ul><hr /><h3 id="key-considerations"><span class="mr-2">Key Considerations</span><a href="#key-considerations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>To make sure your setup runs smoothly, here are some important points:</p><h4 id="1-networking"><span class="mr-2">1. <strong>Networking</strong></span><a href="#1-networking" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><strong>Challenge</strong>: Your IoT devices are likely on your local network, while Docker containers have their own network by default.<li><strong>Solution</strong>: Use <code class="language-plaintext highlighter-rouge">network_mode: host</code> in the Telegraf service (as shown above) so it can directly access devices on your home network. If you prefer isolated networks, map ports or ensure devices can reach container IPs.</ul><h4 id="2-data-persistence"><span class="mr-2">2. <strong>Data Persistence</strong></span><a href="#2-data-persistence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><strong>Why</strong>: You don’t want to lose data if a container restarts.<li><strong>Solution</strong>: Use Docker volumes for InfluxDB (and Grafana if you use it), as shown in the example above.</ul><h4 id="3-security"><span class="mr-2">3. <strong>Security</strong></span><a href="#3-security" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><strong>Network Security</strong>: Keep your home server off the public internet unless necessary. For remote access, use a VPN or secure tunnel.<li><strong>Credentials</strong>: Manage sensitive info (e.g., InfluxDB tokens) with Docker secrets or environment variables, not hardcoded in files.<li><strong>Updates</strong>: Regularly update Docker images and software to stay secure.</ul><h4 id="4-resource-management"><span class="mr-2">4. <strong>Resource Management</strong></span><a href="#4-resource-management" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><strong>Why</strong>: A home server might have limited resources (e.g., CPU, memory).<li><strong>Solution</strong>: Monitor usage with <code class="language-plaintext highlighter-rouge">docker stats</code> and set limits if needed:<div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="na">telegraf</span><span class="pi">:</span>
  <span class="na">deploy</span><span class="pi">:</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="na">limits</span><span class="pi">:</span>
        <span class="na">cpus</span><span class="pi">:</span> <span class="s1">'</span><span class="s">0.5'</span>
        <span class="na">memory</span><span class="pi">:</span> <span class="s">512M</span>
</pre></table></code></div></div></ul><h4 id="5-visualization"><span class="mr-2">5. <strong>Visualization</strong></span><a href="#5-visualization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><strong>Suggestion</strong>: Add Grafana to visualize your IoT data. It pairs well with InfluxDB and Telegraf, giving you real-time dashboards (included in the example above).</ul><hr /><h3 id="final-thoughts"><span class="mr-2">Final Thoughts</span><a href="#final-thoughts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Your plan to use a home server with Docker Compose and Telegraf is a solid foundation for your IoT project. It’s budget-friendly, manageable, and scalable. Just focus on networking, security, and resource usage, and you’ll have a reliable system for collecting and analyzing IoT data. If you need help tweaking configs or troubleshooting, feel free to reach out—I’m happy to assist!</p><h2 id="why-node-red-is-not-included"><span class="mr-2">Why Node red is not included</span><a href="#why-node-red-is-not-included" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="thinking--1"><span class="mr-2">Thinking …</span><a href="#thinking--1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Let me clarify why Node-RED isn’t explicitly mentioned in the latest stack.</p><p>First, Telegraf and Node-RED serve different primary purposes in an IoT setup. Telegraf is mainly a data collection agent that gathers metrics from various sources and sends them to databases like InfluxDB. It’s lightweight and efficient for this task.</p><p>Node-RED, on the other hand, is a flow-based programming tool that’s great for creating automation workflows, handling data processing, and integrating different services. It can be used for data collection, but it’s more versatile and resource-intensive compared to Telegraf.</p><p>In the latest stack, Telegraf is used for its efficiency in collecting and forwarding data to InfluxDB. However, if you need more complex data processing or automation (like triggering actions based on sensor data), you can still include Node-RED in your Docker Compose setup alongside Telegraf.</p><p>So, to answer your question: Node-RED isn’t included because Telegraf handles the data collection efficiently, but you can add Node-RED if your project requires additional processing or automation features.</p><p>Based on your question, it seems you’re wondering why Node-RED isn’t included in the latest technology stack, especially since Telegraf is being used. Let me clarify the roles of these tools and explain how they fit into your IoT project.</p><p>Key Points Telegraf is primarily a data collection agent. It efficiently gathers metrics from various sources (like IoT devices via MQTT) and sends them to databases like InfluxDB. It’s lightweight and optimized for this specific task. Node-RED is a flow-based programming tool used for automation and data processing. It allows you to create workflows that can handle tasks like triggering actions based on sensor data, integrating with other services, or even collecting data. However, it’s more versatile and resource-intensive compared to Telegraf. In the latest stack, Telegraf is included because it excels at collecting and forwarding data to InfluxDB with minimal overhead. This makes it a great choice for efficiently managing data from your IoT devices.</p><p>However, if your project requires more complex functionality—such as processing data, automating responses (e.g., sending alerts when a sensor value exceeds a threshold), or integrating with other services—you can still add Node-RED to your Docker Compose setup alongside Telegraf.</p><p>Should You Include Node-RED? If your project only needs data collection and storage, Telegraf paired with InfluxDB and Grafana is sufficient and efficient. If you need automation or more advanced data processing, adding Node-RED is a good idea. It can work in parallel with Telegraf or even replace it for certain tasks, depending on your needs. Here’s how you can include Node-RED in your Docker Compose setup:</p><p>yaml</p><p>Collapse</p><p>Wrap</p><p>Copy services: nodered: image: nodered/node-red:latest ports: - “1880:1880” volumes: - nodered_data:/data</p><p>volumes: nodered_data: Access Node-RED at http://<your-server-ip>:1880 to create and manage your flows. Final Answer Node-RED wasn’t included in the latest stack because Telegraf efficiently handles data collection for your IoT devices. However, if your project requires additional automation or data processing, you can easily add Node-RED to your Docker Compose setup to complement Telegraf. Let me know if you’d like help integrating it!</your-server-ip></p><h3 id="answer-to-your-query"><span class="mr-2">Answer to Your Query</span><a href="#answer-to-your-query" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>You’re wondering why Node-RED isn’t included in the latest stack and whether it’s because Telegraf is being used instead. Let me explain the reasoning behind this and how these tools fit into an IoT setup.</p><h4 id="why-node-red-isnt-included"><span class="mr-2">Why Node-RED Isn’t Included</span><a href="#why-node-red-isnt-included" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>Node-RED isn’t part of the latest stack because <strong>Telegraf</strong> is handling the data collection role efficiently. Telegraf is a lightweight data collection agent designed to gather metrics from various sources—like IoT devices via MQTT—and send them to databases such as InfluxDB. It’s optimized for this specific task, making it a streamlined choice for collecting and forwarding data without unnecessary overhead.</p><p>In this setup, Telegraf works alongside InfluxDB (for storing data) and Grafana (for visualizing it), providing a simple and effective solution for monitoring IoT device metrics.</p><h4 id="how-node-red-differs-from-telegraf"><span class="mr-2">How Node-RED Differs from Telegraf</span><a href="#how-node-red-differs-from-telegraf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>While Telegraf focuses on data collection, <strong>Node-RED</strong> serves a different purpose. It’s a flow-based programming tool that excels at creating automation workflows, processing data, and integrating with various services. For example, Node-RED can:</p><ul><li>Trigger actions (e.g., send an alert when a sensor value exceeds a threshold).<li>Transform or enrich data before storing it.<li>Connect multiple systems (e.g., link IoT devices to APIs or external services).</ul><p>Although Node-RED <em>can</em> collect data, it’s more versatile and resource-intensive than Telegraf, which is why it’s not included by default when the primary need is straightforward data collection.</p><h4 id="can-you-still-use-node-red"><span class="mr-2">Can You Still Use Node-RED?</span><a href="#can-you-still-use-node-red" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>Absolutely! If your project requires more than just data collection—such as automation or advanced data processing—you can add Node-RED to your setup alongside Telegraf. They can complement each other:</p><ul><li><strong>Telegraf</strong> collects raw data and sends it to InfluxDB.<li><strong>Node-RED</strong> processes that data or handles additional tasks like automation.</ul><p>Here’s an example of how to add Node-RED to your Docker Compose file:</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="na">services</span><span class="pi">:</span>
  <span class="na">nodered</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nodered/node-red:latest</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">1880:1880"</span>  <span class="c1"># Access Node-RED at http://&lt;your-server-ip&gt;:1880</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">nodered_data:/data</span>

<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">nodered_data</span><span class="pi">:</span>
</pre></table></code></div></div><p>Once added, you can access Node-RED’s web interface to build your workflows.</p><h4 id="when-to-include-node-red"><span class="mr-2">When to Include Node-RED</span><a href="#when-to-include-node-red" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><strong>Stick with Telegraf alone</strong> if you only need to collect and store data for visualization (e.g., with InfluxDB and Grafana).<li><strong>Add Node-RED</strong> if you need automation, data transformation, or integration with other services beyond what Telegraf provides.</ul><h4 id="summary"><span class="mr-2">Summary</span><a href="#summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>Node-RED isn’t in the latest stack because Telegraf efficiently covers the data collection needs. However, it’s not an either/or choice—you can include Node-RED if your project demands its extra capabilities. Let me know if you’d like help setting it up or tailoring it to your needs!</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/esp32/'>ESP32</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/docker/" class="post-tag no-text-decoration" >docker</a> <a href="/tags/esp32/" class="post-tag no-text-decoration" >esp32</a> <a href="/tags/cam/" class="post-tag no-text-decoration" >cam</a> <a href="/tags/sensors/" class="post-tag no-text-decoration" >sensors</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Iot Project with ESP 32 - JMC-memo&amp;url=https://gitjmc.github.io/posts/iot-project/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Iot Project with ESP 32 - JMC-memo&amp;u=https://gitjmc.github.io/posts/iot-project/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://gitjmc.github.io/posts/iot-project/&amp;text=Iot Project with ESP 32 - JMC-memo" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://gitjmc.github.io/posts/iot-project/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <a href="http://service.weibo.com/share/share.php?title=Iot Project with ESP 32 - JMC-memo&amp;url=https://gitjmc.github.io/posts/iot-project/" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/esp32/">ESP 32</a><li><a href="/posts/iot-project/">Iot Project with ESP 32</a><li><a href="/posts/secureFormQualtrics/">How to secure Form in Qualtrics</a><li><a href="/posts/mosquitto-tls/">Mosquitto with Docker Compose and Base Authentication & Let's Encrypt (DuckDNS)</a><li><a href="/posts/docker-install/">Install Docker on Deepin 20.x</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/tuto/">tuto</a> <a class="post-tag" href="/tags/angular/">angular</a> <a class="post-tag" href="/tags/dev/">dev</a> <a class="post-tag" href="/tags/access/">access</a> <a class="post-tag" href="/tags/nextcloud/">nextcloud</a> <a class="post-tag" href="/tags/real-time/">real-time</a> <a class="post-tag" href="/tags/wireguard/">wireguard</a> <a class="post-tag" href="/tags/api/">api</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/iot-system-for-monitoring-a-dam-water-pumping-station/"><div class="card-body"> <em class="timeago small" data-ts="1739540100" > 2025-02-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>IoT system for monitoring a dam water pumping station (G)</h3><div class="text-muted small"><p> It seems like you’re asking about an IoT system for monitoring a dam water pumping station, which I’ll interpret as a setup to manage and monitor water pumping operations at a dam—covering aspects ...</p></div></div></a></div><div class="card"> <a href="/posts/setting-up-contoling-and-minotoring-an-iot-system/"><div class="card-body"> <em class="timeago small" data-ts="1739574720" > 2025-02-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Setting up, contoling and minotoring an IoT system (G)</h3><div class="text-muted small"><p> Setting up an IoT system to control and monitor your garden irrigation, pool pump, indoor/outdoor lights, heater, and other devices with Angular, Spring Boot, and Docker is a great choice, as these...</p></div></div></a></div><div class="card"> <a href="/posts/docker-install/"><div class="card-body"> <em class="timeago small" data-ts="1645992180" > 2022-02-27 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Install Docker on Deepin 20.x</h3><div class="text-muted small"><p> Cet article montre comment peut-on installer docker dans Deepin1 version 20.x et plus. MAJ ‘2022-04-18’ Solution install Docker Prerequistes $ sudo apt-get update $ sudo apt install -y apt...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/manage-encrypt-decrypt-with-gpg-key/" class="btn btn-outline-primary" prompt="Older"><p>Manage, Encrypt and Decrypt with gpg Keys</p></a> <a href="/posts/common-cli/" class="btn btn-outline-primary" prompt="Newer"><p>Common CLI on linux</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">Jerbi Mohamed Chamseddine</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/tuto/">tuto</a> <a class="post-tag" href="/tags/angular/">angular</a> <a class="post-tag" href="/tags/dev/">dev</a> <a class="post-tag" href="/tags/access/">access</a> <a class="post-tag" href="/tags/nextcloud/">nextcloud</a> <a class="post-tag" href="/tags/real-time/">real-time</a> <a class="post-tag" href="/tags/wireguard/">wireguard</a> <a class="post-tag" href="/tags/api/">api</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-REJ95ZFTQX"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-REJ95ZFTQX'); }); </script>
